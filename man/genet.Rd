% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genet.R
\name{genet}
\alias{genet}
\title{Generate Networks}
\usage{
genet(
  n,
  multiedges = T,
  assignments,
  cards,
  dc = TRUE,
  target_centrality,
  target_degree = NA,
  verbose = FALSE,
  return_root = FALSE
)
}
\arguments{
\item{n}{number of random networks to generate.}

\item{multiedges}{logical. If \code{FALSE}, omit multiedges.}

\item{assignments}{matrix with non-negative entries and whose rows encode the
membership assignments of types.}

\item{cards}{vector of type cardinalities. Must be whole numbers.}

\item{dc}{logical. If \code{TRUE}, generate networks with target degree
centrality; if \code{FALSE}, generate networks with target eigencentrality.}

\item{target_centrality}{vector of target centralities.}

\item{target_degree}{target average expected degree. This argument is
required only when generating networks with target eigencentrality (i.e.
\code{dc = FALSE}).}

\item{verbose}{logical. If \code{TRUE}, give verbose output.}

\item{return_root}{logical. Should the degree correction terms be returned?}
}
\value{
A list with \code{n} \code{igraph} graph objects. If 
\code{return_root = TRUE}, a list with the following two objects:
\item{graphs}{a list with \code{n} \code{igraph} graph objects;}
\item{root}{a vector with the degree correction terms.}
}
\description{
Generate networks with overlapping communities and target node centralities.
}
\details{
The rows of the matrix argument `assignments` are normalized so as
to have unit norm.
}
\examples{
assignments <- Matrix::sparseMatrix(i = c(1, 2, 3, 3, 3),
j = c(1, 2, 1, 2, 3),
x = c(1, 1, 1, 2, 1))
row_norms <- apply(assignments, 1, function(x) sqrt(sum(x ^ 2)))
assignments <- Matrix::diag(row_norms ^ -1) \%*\% assignments

cards <- c(4, 4, 6)

target_degree <- c(4, 6, 10)

g <- genet(n = 4, multiedges = F, assignments = assignments, cards = cards, dc = T,
           target_centrality = target_degree)
           
par(mfrow = c(2, 2), mar = rep(0, 4))
invisible(lapply(X = g, FUN = igraph::plot.igraph, vertex.size = 4,
                 vertex.label = NA, vertex.color = "blue", edge.arrow.mode = 0))

}
